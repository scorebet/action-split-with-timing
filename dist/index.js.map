{"version":3,"file":"index.js","mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/NA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["../webpack://javascript-action/./splitter.js","../webpack://javascript-action/../../../../opt/homebrew/lib/node_modules/@vercel/ncc/dist/ncc/@@notfound.js","../webpack://javascript-action/external node-commonjs \"fs\"","../webpack://javascript-action/external node-commonjs \"path\"","../webpack://javascript-action/webpack/bootstrap","../webpack://javascript-action/webpack/runtime/compat","../webpack://javascript-action/./index.js"],"sourcesContent":["var fsPromise = require(\"fs\").promises;\nvar fs = require(\"fs\");\nvar convert = require(\"xml-js\");\nvar glob = require(\"glob\");\nvar path = require(\"path\");\nvar Deque = require(\"collections/deque\");\nvar Map = require(\"collections/map\");\nconst core = require(\"@actions/core\");\n\nlet split = function (testPath, nodeIndex, nodeTotal, filesToExlude = []) {\n  verify(testPath, nodeIndex, nodeTotal);\n  return new Promise((resolve) => {\n    glob(\n      buildTestPattern(testPath),\n      { ignore: filesToExlude.map((value) => `${testPath}/**/${value}`) },\n      function (er, files) {\n        if (er != null) {\n          throw new Error(`Error: Reading files from ${testPath}: ${er}`);\n        }\n        const tests = files\n          .filter((value, index) => index % nodeTotal === nodeIndex)\n          .map((value) => {\n            return `--tests ${path.parse(value).name}`;\n          })\n          .join(\" \");\n        core.info(`Successfully created tests: ${tests}`);\n        resolve(tests);\n      }\n    );\n  });\n};\n\nlet isTestFilesOnSyncWithTestResults = function (testFiles, testResultFiles) {\n  let missingTests = [];\n  let testResultFilesMap = new Map();\n  testResultFiles.forEach((testResultFile) => {\n    let xml = JSON.parse(convert.xml2json(fs.readFileSync(testResultFile)));\n    let fileNameData = xml.elements[0].attributes.name.split(\".\");\n    let fileName = fileNameData.pop();\n    let packageName = fileNameData.join(\".\");\n    if (!testResultFilesMap.has(fileName)) {\n      testResultFilesMap.add([packageName], fileName);\n    } else {\n      let testResultFilePackages = testResultFilesMap.get(fileName);\n      testResultFilePackages.push(packageName);\n      testResultFilesMap.add(testResultFilePackages, fileName);\n    }\n  });\n  testFiles.forEach((testFile) => {\n    core.info(`-=-= test file: ${testFile}`);\n    let fileData = fs.readFileSync(testFile, \"UTF-8\");\n    let regex = /^(\\s+)?package(\\s+)?([a-z][a-z0-9_]*(\\.[a-z0-9_]+)+[0-9a-z_])/;\n    let fileName = path.parse(testFile).name;\n    let packageName = fileData.match(regex)[3];\n    if (testResultFilesMap.has(fileName)) {\n      let testResultFilePackages = testResultFilesMap.get(fileName);\n      if (testResultFilePackages.includes(packageName)) {\n        testResultFilesMap.add(\n          testResultFilePackages.filter((item) => item !== packageName),\n          fileName\n        );\n      } else {\n        missingTests.push({\n          name: fileName,\n          package: packageName,\n        });\n      }\n      if (testResultFilesMap.get(fileName).length <= 0) {\n        testResultFilesMap.delete(fileName);\n      }\n    } else {\n      missingTests.push({\n        name: fileName,\n        package: packageName,\n      });\n    }\n  });\n  if (missingTests.length != 0) {\n    core.info(\n      `WARNING: Test[${testFiles.length}] and TestResult[${\n        testResultFiles.length\n      }] are not in sync, unsync tests: ${JSON.stringify(missingTests)}`\n    );\n    return false;\n  } else {\n    core.info(\n      `SUCCESS: Test[${testFiles.length}] and TestResult[${testResultFiles.length}] are in sync, using timings for tests`\n    );\n    return true;\n  }\n};\n\nlet splitWithTiming = async function (\n  testPath,\n  testResultPath,\n  nodeIndex,\n  nodeTotal,\n  filesToExlude = []\n) {\n  verify(testPath, nodeIndex, nodeTotal, filesToExlude);\n  return new Promise((resolve) => {\n    glob(\n      buildTestPattern(testPath),\n      { ignore: filesToExlude.map((value) => `${testPath}/**/${value}`) },\n      function (testFilesError, testFiles) {\n        if (testFilesError != null) {\n          throw new Error(\n            `Error: Reading files from ${testPath}: ${testFilesError}`\n          );\n        }\n        glob(\n          `${testResultPath}/**/*.xml`,\n          { ignore: filesToExlude.map((value) => `${testPath}/**/${value}`) },\n          async function (testResultFilesError, testResultFiles) {\n            if (testResultFilesError != null) {\n              throw new Error(\n                `Error: Reading files from ${testPath}: ${testResultFilesError}`\n              );\n            }\n            if (!isTestFilesOnSyncWithTestResults(testFiles, testResultFiles)) {\n              let tests = await split(\n                testPath,\n                nodeIndex,\n                nodeTotal,\n                filesToExlude\n              );\n              resolve(tests);\n            } else {\n              var deque = new Deque();\n              var testResultTotalTime = 0;\n              var i = 0;\n              for (i = 0; i < testResultFiles.length; i++) {\n                let xml = JSON.parse(\n                  convert.xml2json(await fsPromise.readFile(testResultFiles[i]))\n                );\n                let testResultName = xml.elements[0].attributes.name;\n                let testResultTime = parseFloat(\n                  xml.elements[0].attributes.time\n                );\n                testResultTotalTime += testResultTime;\n                deque.add({ name: testResultName, time: testResultTime });\n              }\n              let testChunkMaxTime = testResultTotalTime / nodeTotal;\n              deque = deque.sorted((a, b) => {\n                return a.time - b.time;\n              });\n              for (i = 0; i < nodeTotal; i++) {\n                let testNames = [];\n                var testChunkCurrentTime = 0;\n                var isPollLast = true;\n                while (\n                  deque.length != 0 &&\n                  deque.length >= nodeTotal - i &&\n                  (testChunkCurrentTime < testChunkMaxTime ||\n                    i === nodeTotal - 1)\n                ) {\n                  let result = isPollLast ? deque.pop() : deque.shift();\n                  testNames.push(result.name);\n                  testChunkCurrentTime += result.time;\n                  isPollLast = false;\n                  if (deque.length !== 0 && i === nodeTotal - 1) {\n                    continue;\n                  } else if (\n                    deque.length !== 0 &&\n                    testChunkCurrentTime + deque.peek().time >\n                      testChunkMaxTime &&\n                    i < nodeTotal - nodeTotal / 4\n                  ) {\n                    break;\n                  }\n                }\n                if (i === nodeIndex) {\n                  if (i == nodeTotal - 1 && deque.length != 0) {\n                    throw new Error(\n                      `Error: Some test was not consumed: ${deque.length}`\n                    );\n                  }\n                  let tests = testNames\n                    .map((value) => {\n                      return `--tests ${value}`;\n                    })\n                    .join(\" \");\n                  core.info(\n                    `Successfully created tests using timings: ${tests}`\n                  );\n                  resolve(tests);\n                  return;\n                }\n              }\n              throw new Error(\"Error: Unable to create tests\");\n            }\n          }\n        );\n      }\n    );\n  });\n};\n\nlet buildTestPattern = function (testPath) {\n  return `${testPath}/**/*Test.+(kt|java)`;\n};\n\nlet verify = function (directoryPath, nodeIndex, nodeTotal) {\n  if (directoryPath === \"\") {\n    throw new Error(\"Error: Require module\");\n  }\n  if (nodeIndex < 0) {\n    throw new Error(`Error: Invalid node-index: ${nodeIndex}`);\n  }\n  if (nodeTotal <= 0) {\n    throw new Error(`Error: Invalid node-total: ${nodeTotal}`);\n  }\n  if (nodeIndex >= nodeTotal) {\n    throw new Error(\n      `Error: Invalid node-index: ${nodeIndex} is out of bounds, node-total: ${nodeTotal}`\n    );\n  }\n};\n\nmodule.exports = {\n  split: split,\n  splitWithTiming: splitWithTiming,\n  buildTestPattern: buildTestPattern,\n};\n",null,"module.exports = require(\"fs\");","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","const core = require(\"@actions/core\");\nconst split = require(\"./splitter\").split;\nconst splitWithTiming = require(\"./splitter\").splitWithTiming;\nconst buildTestPattern = require(\"./splitter\").buildTestPattern;\nconst path = require(\"path\");\nconst glob = require(\"glob\");\n\n// most @actions toolkit packages have async methods\nasync function run() {\n  try {\n    const testPath = path.resolve(core.getInput(\"test-path\", true));\n    const nodeIndex = parseInt(core.getInput(\"node-index\", true));\n    const nodeTotal = parseInt(core.getInput(\"node-total\", true));\n    const testResultPath = path.resolve(core.getInput(\"test-result-path\"));\n    const testExclude = getInputAsArray(\"test-exclude\");\n\n    core.info(\n      `Creating ${testPath} tests for index ${nodeIndex} of total ${nodeTotal} with files to ignore: ${testExclude}`\n    );\n\n    var tests = \"\";\n    if (glob.sync(buildTestPattern(testPath)).length === 0) {\n      core.setFailed(`ERROR: Test path does not exist: ${testPath}`);\n      return;\n    }\n    if (glob.sync(`${testResultPath}/**/*.xml`).length === 0) {\n      core.info(\n        `TestResult[${testResultPath}] does not exist, using split without timings`\n      );\n      tests = await split(testPath, nodeIndex, nodeTotal, testExclude).catch(\n        core.setFailed\n      );\n    } else {\n      tests = await splitWithTiming(\n        testPath,\n        testResultPath,\n        nodeIndex,\n        nodeTotal,\n        testExclude\n      ).catch(core.setFailed);\n    }\n\n    core.setOutput(\"tests\", tests);\n  } catch (error) {\n    core.setFailed(error.message);\n  }\n}\n\nfunction getInputAsArray(name, isRequired = false) {\n  return core\n    .getInput(name, isRequired)\n    .split(\"\\n\")\n    .map((s) => s.trim())\n    .filter((x) => x !== \"\");\n}\n\nrun();\n"],"names":[],"sourceRoot":""}